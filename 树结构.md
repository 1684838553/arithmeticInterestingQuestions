## 树

1. 先序遍历 `根左右`
2. 中序遍历 `左根右`
3. 后序遍历 `左右根`
4. `深度`是指树的根节点到任一叶子节点路径上节点的数量。

### 相关术语

1. `树`：n(n>=0)个节点构成的有限集合

   n === 0 时，称为空树

2. `节点的度`：节点的子树个数

3. `树的度`：树的所有节点中最大的度数

4. `叶子节点`：度为 0 的节点（没有子节点）

5. `树的深度`：树中所有节点中最大层次时这棵树的深度

### 二叉树

1. 定义：

   - 二叉树可以为空，也就是没有节点

   - 若不为空，则它是由根节点和称为其左子树和右子树的两个不相交的二叉树组成

2. 特点

   - 一个二叉树第 i 层最多节点数：`2^(i-1)`

   - 深度为 k 的二叉树有最大节点总数：`2^k-1`

   - 对任何非空二叉树，若 n0 表示叶子节点个数，n2 是度为 2 `(有两个子节点的节点)`的非叶子节点个数，那么两者关系满足` n0 = n2 + 1`

3. 五种形态

   ```
   // 1. 为空


   // 2.
           rootVal
    #(左)           #(右)

   // 3.
          rootVal
    leftVal          #(右)
    #       #


   // 4.
            rootVal
          #          rightVal
                    #       #

   // 5.
             rootVal
    leftVal           rightVal
    #      #         #       #
   ```

4. 完美二叉树（满二叉树）：除叶子节点外，每层节点都有 2 个子节点

5. 完全二叉树

   - 除二叉树最后一层外，其他各层的节点数都达到最大数

   - 且最后一层从左向右的叶子节点`连续存在`，只缺右侧若干节点

   - 完美二叉树是特殊的完全二叉树

6. 二叉树的存储

   - 使用数组

   - 使用链表

### 二叉搜索树

1. 定义：二叉搜索树是一颗二叉树，可以为空，如果不为空，

   - 非空左子树的所有键值小于其根节点键值

   - 非空右子树所有键值大于其根节点的键值

   - 左右子树本身也是二叉搜索树

   ```
   // 二叉搜索树
               30
           15     41
           # #    33 50

       // 不满足二叉搜索树（5小于10）
               18
           10      20
         7   5    #   22
   ```

2. 实现代码

   ```javascript
   // 封装二叉搜索树
   function BinarySearchTree() {
     // 封装节点类
     function Node(val) {
       this.val = val;
       this.left = null;
       this.right = null;
     }

     this.root = null;

     // 插入
     BinarySearchTree.prototype.insert = function (val) {
       let newNode = new Node(val);
       if (!this.root) {
         this.root = newNode;
       } else {
         this.insertNode(this.root, newNode);
       }
     };

     BinarySearchTree.prototype.insertNode = function (rootNode, newNode) {
       if (rootNode.val > newNode.val) {
         // 向左查找
         if (!rootNode.left) {
           rootNode.left = newNode;
         } else {
           this.insertNode(rootNode.left, newNode);
         }
       } else {
         // 向右查找
         if (!rootNode.right) {
           rootNode.right = newNode;
         } else {
           this.insertNode(rootNode.right, newNode);
         }
       }
     };

     // 查找某个值，找到返回true,没有找到，返回false
     BinarySearchTree.prototype.search = function (val) {
       let root = this.root;
       while (root) {
         if (val < root.val) {
           root = root.left;
         } else if (val > root.val) {
           root = root.right;
         } else {
           return true;
         }
       }
       return false;
     };

     // 通过中序遍历方式遍历所有节点 左中右
     BinarySearchTree.prototype.midOrderTraversal = function (handler) {
       this.midOrderTraversalNode(this.root, handler);
     };
     BinarySearchTree.prototype.midOrderTraversalNode = function (
       rootNode,
       handler
     ) {
       if (rootNode) {
         // 处理经过节点的子节点
         this.midOrderTraversalNode(rootNode.left, handler);
         // 处理经过的节点
         handler(rootNode.val);
         this.midOrderTraversalNode(rootNode.right, handler);
       }
     };

     // 通过先序遍历方式遍历所有节点,根左右
     BinarySearchTree.prototype.preOrderTraversal = function (handler) {
       this.preOrderTraversalNode(this.root, handler);
     };
     BinarySearchTree.prototype.preOrderTraversalNode = function (
       rootNode,
       handler
     ) {
       if (rootNode) {
         // 处理经过的节点
         handler(rootNode.val);
         // 处理经过节点的子节点
         this.preOrderTraversalNode(rootNode.left, handler);
         this.preOrderTraversalNode(rootNode.right, handler);
       }
     };

     // 通过后序遍历方式遍历所有节点,左右跟
     BinarySearchTree.prototype.postOrderTraversal = function (handler) {
       this.postOrderTraversalNode(this.root, handler);
     };
     BinarySearchTree.prototype.postOrderTraversalNode = function (
       rootNode,
       handler
     ) {
       if (rootNode) {
         // 处理经过节点的子节点
         this.postOrderTraversalNode(rootNode.left, handler);
         this.postOrderTraversalNode(rootNode.right, handler);

         // 处理经过的节点
         handler(rootNode.val);
       }
     };

     // 返回树的最小值
     BinarySearchTree.prototype.min = function () {
       let root = this.root;
       let min;
       while (root) {
         min = root.val;
         root = root.left;
       }

       return min;
     };

     // 返回树的最大值
     BinarySearchTree.prototype.max = function () {
       let root = this.root;
       let max;
       while (root) {
         max = root.val;
         root = root.right;
       }

       return max;
     };

     // 从树中移除某个值
     // 1. 该节点是叶子节点 2. 有一个子节点 3. 右两个子节点
     BinarySearchTree.prototype.remove = function (val) {
       // 寻找要删除的节点
       let current = this.root;
       let parent = null;
       let isLeftChild = true;

       while (current.val !== val) {
         parent = current;
         if (current.val > val) {
           isLeftChild = true;
           current = current.left;
         } else {
           isLeftChild = false;
           current = current.right;
         }

         // 没找到该节点，返回false
         if (!current) return false;
       }

       // 删除节点为叶子节点
       if (!current.left && !current.right) {
         if (current === this.root) {
           this.root = null;
         } else if (isLeftChild) {
           parent.left = null;
         } else {
           parent.right = null;
         }
       }

       // 删除节点有一个子节点
       else if (!current.right) {
         if (current === this.root) {
           this.root = current.left;
         }
         if (isLeftChild) {
           parent.left = current.left;
         } else {
           parent.right = current.left;
         }
       } else if (!current.left) {
         if (current === this.root) {
           this.root = current.right;
         }
         if (isLeftChild) {
           parent.left = current.right;
         } else {
           parent.right = current.right;
         }
       }

       // 删除节点有两个子节点
     };
   }

   let tree = new BinarySearchTree();
   tree.insert(11);
   tree.insert(7);
   tree.insert(15);
   tree.insert(5);
   tree.insert(3);
   tree.insert(9);
   tree.insert(8);
   tree.insert(10);
   tree.insert(13);
   tree.insert(12);
   tree.insert(14);
   tree.insert(20);
   tree.insert(18);
   tree.insert(25);
   tree.insert(6);
   console.log(tree.root);
   let result = "";
   function hander(val) {
     result += val + " ";
   }
   // tree.preOrderTraversal(hander);
   // tree.midOrderTraversal(hander);
   tree.postOrderTraversal(hander);
   console.log(result, tree.min(), tree.max(), tree.search(34));
   ```
