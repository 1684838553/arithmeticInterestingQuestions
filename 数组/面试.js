/**
 * 某公司组织一场公开招聘活动，假设由于人数和场地的限制，每人每次面试的时长不等
 * 并已经安排给定，用(S1,E1)、(S2,E2)、(Sj,Ej)...(Si<Ei,均为非负整数)表示每场
 * 面试的开始和结束时间。
 * 面试采用一对一的方式，即一名面试官同时只能面试一名应试者，一名面试官完成一次
 * 面试后可以立即进行下一场面试，且每个面试官的面试人次不超过m
 * 为了支撑招聘活动高效顺利进行，请你计算至少需要多少名面试官。
 * 输入描述：
 * 输入的第一行为面试官的最多面试人次m,第二行为当天总的面试场次n，接下来的n行
 * 为每场面试的起始时间和结束时间，起始时间和结束时间用空格分割
 * 其中，1<=n,m<=500
 * 输出描述：
 * 输出一个证书，表示至少需要的面试官数量。
 * 示例1
 * 输入：
 * 2
 * 5
 * 1 2
 * 2 3
 * 3 4
 * 4 5
 * 5 6
 *
 * 输出：
 * 3
 * 说明
 * 总共有5场面试，且面试时间都不重叠，但每个面试官最多只能面试2人次，所以需要3名面试官。
 * 示例2
 * 输入：
 * 3
 * 3
 * 1 2
 * 2 3
 * 3 4
 * 输出：
 * 1
 * 说明
 * 总共有3场面试，面试时间不重叠，每个面试官最多能面试3人次，所以只需要1名面试官
 *
 * 示例3
 * 输入：
 * 3
 * 3
 * 8 35
 * 5 10
 * 1 3
 * 输出：
 * 2
 * 说明
 * 总共有3场面试，[5,10]和[8,35]有重叠，所以至少需要2名面试官
 */
let m = 3;
let t = [
  [8, 35],
  [5, 10],
  [1, 3],
];

// m 一个面试官面试最多人次 t 每场面试的开始时间，结束时间
function offer(m, t) {}
console.log(offer(m, t));

// yang
function offer(m, t) {
  let cnt = [];
  let free = [];
  t.sort((a, b) => {
    return a[0] - b[0];
  });
  for (let k = 0; k < t.length; k++) {
    let s = t[k][0],
      e = t[k][1];
    let i = 0;
    for (; i < free.length; i++) {
      if (free[i] <= s && cnt[i] < m) {
        free[i] = e;
        cnt[i]++;
        break;
      }
    }
    if (i == free.length) {
      let new_ = free.length;
      free[new_] = e;
      cnt[new_] = 1;
    }
  }
  console.log(cnt.length);
}
offer(m, t);
