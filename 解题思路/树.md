## 树

### 1. 树的遍历

1. 前序遍历： 中左右

2. 中序遍历： 左中右

3. 后序遍历： 左右中

### 2. 层次遍历

```javascript
var levelOrder = function (root) {
  const result = [];
  if (!root) return result;

  const queue = [];
  queue.push(root);

  while (queue.length) {
    const ans = [];
    const n = queue.length;
    // 每次循环n的长度不一样，区分层次的值
    for (let i = 0; i < n; i++) {
      const node = queue.shift();
      ans.push(node.val);

      if (node.left) {
        queue.push(node.left);
      }

      if (node.right) {
        queue.push(node.right);
      }
    }

    result.push(ans);
  }
  return result;
};
```

### 3. 树的最大深度和最小深度

```javascript
// 最小深度
var minDepth = function (root) {
  if (!root) return 0;
  if (!root.left) return minDepth(root.right) + 1;
  if (!root.right) return minDepth(root.left) + 1;
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
};

// 最大深度
// 或者层次遍历，返回数组的长度
var maxDepth = function (root) {
  if (!root) return 0;
  const left = maxDepth(root.left);
  const right = maxDepth(root.right);

  return Math.max(left, right) + 1;
};
```

### 4. 路径总和

[路径总和](https://leetcode.cn/problems/path-sum/description/?envType=list&envId=tEsVsxjC)

```javascript
var hasPathSum = function (root, targetSum) {
  if (!root) {
    return 0;
  }

  if (root.left === null && root.right === null) {
    return targetSum - root.val === 0;
  }

  return (
    hasPathSum(root.left, targetSum - root.val) ||
    hasPathSum(root.right, targetSum - root.val)
  );
};
```

### 5. 填充每个节点的下一个右侧节点指针

```javascript
var connect = function (root) {
  if (!root) return root;

  const queue = [];
  queue.push(root);

  while (queue.length) {
    const n = queue.length;

    for (let i = 0; i < n; i++) {
      const node = queue.shift();
      if (i < n - 1) {
        node.next = queue[0];
      }

      if (node.left) {
        queue.push(node.left);
      }

      if (node.right) {
        queue.push(node.right);
      }
    }
  }

  return root;
};
```

### 6. 二叉树的最近公共祖先

```javascript
var lowestCommonAncestor = function (root, p, q) {
  // 迭代解法

  const stack = [root];
  // key为某个节点，value为root
  const parent = new Map();
  parent.set(root, null);

  while (!parent.has(p) || !parent.has(q)) {
    const node = stack.pop();

    if (node.left !== null) {
      parent.set(node.left, node);
      stack.push(node.left);
    }

    if (node.right !== null) {
      parent.set(node.right, node);
      stack.push(node.right);
    }
  }

  const result = new Set();
  while (p !== null) {
    result.add(p);
    p = parent.get(p);
  }

  while (!result.has(q)) {
    q = parent.get(q);
  }

  return q;
};
```

### 7. 二叉树的序列化与反序列化

```javascript
var serialize = function (root) {
  if (root === null) {
    return "null";
  }

  const left = serialize(root.left);
  const right = serialize(root.right);

  return root.val + "," + left + "," + right;
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function (data) {
  console.log(data, "data");
  const nodes = data.split(",");

  function buildTree() {
    const val = nodes.shift();

    if (val === "null") {
      return null;
    }

    const node = new TreeNode(parseInt(val));
    node.left = buildTree();
    node.right = buildTree();

    return node;
  }

  return buildTree();
};
```
